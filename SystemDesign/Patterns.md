# 📁안정적인 백엔드 패턴 (Design Patterns)

서비스가 커지고 트래픽이 몰리면 단순한 CRUD로는 해결되지 않는 문제들이 발생합니다.
주니어에서 미들웨어(Middleware) 급으로 넘어가기 위해 꼭 알아야 할 패턴들입니다.

---

## 1. Idempotency (멱등성) 패턴

#### 1) 문제 상황 (중복 결제)
* 클라이언트가 "결제 요청" 버튼을 눌렀다.
* 서버가 결제를 처리하고 응답을 보내려는 순간, **네트워크가 끊겼다.**
* 클라이언트는 응답을 못 받았으니(TimeOut), **자동으로(또는 사용자가 다시 눌러서) 재요청**을 보낸다.
* **결과**: 서버는 요청이 두 번 왔으니 **결제를 두 번 승인**해버린다. (돈이 두 번 나감)

#### 2) 해결: Idempotency Key
1. 클라이언트는 요청을 보낼 때 **고유한 키(UUID)**를 생성해서 헤더(`Idempotency-Key`)에 담는다.
2. 서버는 요청을 받으면 이 키를 **Redis(또는 DB)**에 확인한다.
3. **처음 보는 키라면?**: 정상 처리하고, 결과를 저장한다(Key: UUID, Value: Response).
4. **이미 있는 키라면?**: 로직을 다시 실행하지 않고, **저장해둔 결과만 그대로 반환**한다.

> **핵심**: "요청을 100번 보내도, 실제 처리는 딱 1번만 일어난다."

---

## 2. State Machine (상태 머신) 패턴

#### 1) 문제 상황 (스파게티 코드)
주문(Order) 시스템에서 상태 변경 로직이 여기저기 흩어져 있으면 관리가 불가능해진다.
* `if order.status == 'PAYMENT_WAITING': ...`
* `if order.status == 'SHIPPING': ...`

#### 2) Finite State Machine (FSM, 유한 상태 머신)
* 객체의 상태(State)와 그 상태에서 할 수 있는 행동(Transition)을 명확히 정의하는 패턴.
* **상태 전이도(Transition Diagram)**:
    * `[결제대기]` -> (입금확인) -> `[결제완료]`
    * `[결제완료]` -> (상품포장) -> `[배송준비]` -> (출고) -> `[배송중]`
    
#### 3) 장점
* **유효성 검사**: "배송중" 상태에서 바로 "결제대기"로 못 가게 막을 수 있다 (Invalid Transition).
* **Side Effect 관리**: 상태가 변할 때마다 실행되어야 하는 로직(예: 배송 시작 시 문자 발송)을 한곳(`on_enter_shipping`)에 모을 수 있다.

#### 4) 구현 (Python Library)
* 직접 `if/else`로 짜기보다 `django-fsm`이나 `transitions` 라이브러리를 사용하면 깔끔하다.
    ```python
    @transition(field=status, source='new', target='published')
    def publish(self):
        # ... logic ...
    ```

---

## 3. Circuit Breaker (서킷 브레이커) - *Optional*

* **문제**: 외부 API(예: 결제사 은행)가 장애가 났는데, 우리 서버가 계속 요청을 보내면 우리 서버 스레드도 다 대기 상태에 빠져서 같이 죽는다(Cascade Failure).
* **해결**:
    * 에러가 계속 나면 차단기(Circuit)를 내려서, **아예 요청을 보내지 않고 바로 에러를 리턴**한다.
    * 일정 시간이 지난 후 살짝 요청을 보내보고(Half-Open), 정상화되었으면 다시 연결한다.
